/// <summary> Unit which has functions to work with system operational process execution
/// </summary>
unit Utils.Shell;

{$MODE DELPHI}{$H+}

interface

uses
  Classes,
  SysUtils,
  syncobjs,
  Process;

const
  /// <summary> Buffer size for reading the output in chunks </summary>
  MAX_BUFFER = 2048; 

  /// <summary> Exeception message when the program to be executed is not found. </summary>
  EC_EXCEPTION_RUN_COMMAND = 101;

type
  /// <summary> Specific array type for console buffer for reading the output in chunks </summary>
  TConsoleBuffer = array [1..MAX_BUFFER] of Byte;

  /// <summary> This class aims to run an application that can run indefinitely. This execution takes 
  /// place through a specific thread, allowing the main application to perform other tasks in the meantime. 
  /// It is possible to interrupt its execution at any time through the Stop method. It is also possible
  ///  to obtain the output generated by the application using the GetMessage command. </summary>
  TConsoleWatcher = class(TThread)
  private
    FProgram: string;
    FParams: TArray<string>;
    FIsRunning: boolean;
    FExecuted: boolean;
    FMessage: string;
    FProcess: TProcess;
    FLock: TCriticalSection;
    FExitCode: Integer;

    /// <summary> Execute a command and wait until read all the information from the output </summary>
    /// <param name="AProgram"> Program name or command to be executed. </param>
    /// <param name="AParams"> Array of argumentos to be passed to the 
    /// program or command being called </param>
    procedure RunCommand(const AProgram: string; AParams: TArray<string>);

    /// <summary> Convert the buffer content read from RunCommand to string and assign its
    /// value to the FMessage field. </summary>
    /// <param name="ABytesRead"> Number of bytes read from program output.</param>
    /// <param name="ABuffer"> Buffer with content in bytes that was obtained from program output.</param>
    procedure ReadData(const ABytesRead: LongInt; ABuffer: TConsoleBuffer);

    /// <summary> Update FMessage field with contents of AMessage parameters, if there is a content already,
    /// new content is appended to current content. </summary>
    /// <param name="AMessage"> New content to be appended to FMessage field. </param>
    procedure SetMessage(const AMessage: string);

  public

    /// <summary> Class constructor that initialize the thread as suspended, initialize some
    /// internal fields. It is necessary to call the Start method to run the thread which in 
    /// turn executes the program passed as a parameter. </summary>
    /// <param name="AProgram"> Program name or command to be executed. </param>
    /// <param name="AParams"> Array of argumentos to be passed to the 
    /// program or command being called </param>
    constructor Create(const AProgram: string; AParams: TArray<string>);

    /// <summary> Class destructor that release resources allocate by the class. </summary>
    destructor Destroy; override;

    /// <summary> Executes the main loop of the thread running the program passed to the class's
    /// constructor, waiting until its completion or until the Stop method is called. During program 
    /// execution, its output is captured by the thread and stored in an internal field, this value 
    /// can be extracted by the GetMessage function.</summary>
    procedure Execute; override;

    /// <summary> It interrupts the execution of the thread and changes the value of the IsRunning 
    /// property accordingly, in addition to interrupting the execution of the program passed as a 
    /// parameter to the class constructor if it is running. </summary>
    procedure Stop;

    /// <summary> Returns the output of the program being executed and clears the current content 
    /// of this message, so if it is called again its content will not be the same. </summary>
    function GetMessage: string;

    /// <summary>Indicates that the thread is still running waiting for the program to finish.</summary>
    property IsRunning: Boolean read FIsRunning;

    /// <summary>Indicates that the command was executed.</summary>
    property Executed: Boolean read FExecuted;

    /// <summary>Returns the exit code from the executed program.</summary>
    property ExitCode: Integer read FExitCode;    
  end;

  /// <summary> function type to execute programs or commands. See ShellCommand function
  /// for more info. </summary>
  TShellCommandFunc = function (const AProgram: string; AParams: TArray<string>; out AExitCode: Integer): string;

  /// <summary> executes a program and returns the output as funciton result and also provide a execution status
  /// through AStatus out parameter </summary>
  /// <param name="AProgram"> Program name or command to be executed. </param>
  /// <param name="AParams"> Array of arguments to be passed to the 
  /// program or command being called </param>
  /// <param name="AExitCode"> Return the exit code from the executed program. </param>
  function ShellCommand(const AProgram: string; AParams: TArray<string>; out AExitCode: Integer): string;

  /// <summary> Process a raw string and returns an array of strings with the parameters
  /// that were separated by spaces, and consider as single parameter a string between
  /// double quotes. </summary>
  ///
  /// Ex:
  /// MyArray :=  GetParametersFrom('hello "that is my message"'); returns an array with two elements:
  /// ['hello', 'that is my message']
  ///
  /// <param name="AParams"> String parameters separeted by spaces and double quotes. </param>
  function GetParametersFrom(const AParams: string): TArray<string>;

  function CheckIfUserPressedCtrlC(const AFrom: string): Boolean;
  
var
  ShellExecute: TShellCommandFunc = @ShellCommand;

implementation

uses
  {$IF DEFINED(Darwin)}
  Crt,
  {$ENDIF}
  StrUtils;

function CheckIfUserPressedCtrlC(const AFrom: string): Boolean;
begin
  {$IF DEFINED(Darwin)}
  if KeyPressed then            //  <--- CRT function to test key press
    if ReadKey = ^C then        // read the key pressed
    begin
      {$IFDEF DEBUG}
        WriteLn('Ë†c: ', AFrom);
      {$ENDIF}
      Halt(1);
    end;
  {$ENDIF}
end;


constructor TConsoleWatcher.Create(const AProgram: string; AParams: TArray<string>);
begin
  inherited Create(True);
  FLock := TCriticalSection.Create;
  FProcess := nil;
  FreeOnTerminate := False;
  FProgram := AProgram;
  FParams := AParams;
  FIsRunning := False;
  FExecuted := False;
  FMessage := '';
end;

destructor TConsoleWatcher.Destroy;
begin
  FLock.Free;
  FreeAndNil(FProcess);
  inherited Destroy;
end;

procedure TConsoleWatcher.Execute;
begin
  FIsRunning := True;
  while (not Terminated) and (FIsRunning) do
  begin
    try
      RunCommand(FProgram, FParams);
      FExecuted := True;
      Sleep(10);
      CheckIfUserPressedCtrlC('TConsoleWatcher.Execute');
    except
      on E: Exception do
      begin
        FExecuted := True;
        SetMessage(E.Message);
        Stop;
        raise;
      end;
    end;
  end;
end;

procedure TConsoleWatcher.Stop;
begin
  FIsRunning := False;
  if (not FIsRunning) and (Assigned(FProcess)) then
  begin
    try
      if FProcess.Running then
        FProcess.Terminate(0);
    finally
      FreeAndNil(FProcess);
    end;
  end;
end;

procedure TConsoleWatcher.ReadData(const ABytesRead: LongInt; ABuffer: TConsoleBuffer);
var
  LStream: TStream = nil;
  LString: TStringList = nil;
begin
  LStream := TMemoryStream.Create;
  try
    LStream.Write(ABuffer, ABytesRead);
    LStream.Position := 0; 

    LString := TStringList.Create;
    LString.LoadFromStream(LStream);
    LString.TrailingLineBreak := False;

    SetMessage(LString.Text);
  finally
    FreeAndNil(LStream);      
    FreeAndNil(LString);
  end;
end;

procedure TConsoleWatcher.RunCommand(const AProgram: string; AParams: TArray<string>);
var
  LBytesRead: LongInt;
  LBuffer: TConsoleBuffer;
  LParam: string;
begin
  try
    if not Assigned(FProcess) then
    begin
      FProcess := TProcess.Create(nil);
      FProcess.Executable := AProgram;
      FExitCode := 0;

      for LParam in AParams do
        FProcess.Parameters.Add(LParam);

      FProcess.Options := [poUsePipes, poStdErrToOutPut];
      FProcess.Execute;
    end;

    repeat
      LBytesRead := FProcess.Output.Read(LBuffer, MAX_BUFFER);
      ReadData(LBytesRead, LBuffer);
      Sleep(5);
      CheckIfUserPressedCtrlC('TConsoleWatcher.RunCommand');
    until LBytesRead = 0;
    FIsRunning := False;
    FExitCode := FProcess.ExitCode;
  except
    on E: Exception do
    begin
      FIsRunning := False;
      FExecuted := True;
      FExitCode := EC_EXCEPTION_RUN_COMMAND;
      SetMessage(
        'Error when executing: "' + AProgram + 
        '" Message: "' + E.Message + '". ' +
        'Check if the command exists and if it is in the path.');
    end;
  end;
end;

function TConsoleWatcher.GetMessage: string;
begin
  FLock.Enter;
  try
    Result := FMessage;
    FMessage := '';
  finally
    FLock.Leave;
  end;
end;

procedure TConsoleWatcher.SetMessage(const AMessage: string);
begin
  FLock.Enter;
  try
    if FMessage <> '' then
      FMessage := FMessage + #13#10;
    FMessage := FMessage + AMessage;
  finally
    FLock.Leave;
  end;
end;

function ShellCommand(const AProgram: string; AParams: TArray<string>; out AExitCode: Integer): string;
var
  LConsoleWatcher: TConsoleWatcher = nil;
  LResult: string;

  procedure GetOutput(AConsoleWatcher: TConsoleWatcher; out AResult: string);
  var
    LMessage: string;
  begin
    LMessage := AConsoleWatcher.GetMessage;
    if LMessage <> '' then
      AResult := AResult + LMessage;
  end;

begin
  LConsoleWatcher := TConsoleWatcher.Create(AProgram, AParams);
  try
    LConsoleWatcher.Start;

    while not LConsoleWatcher.Executed do
      Sleep(10);

    LResult := '';
    while LConsoleWatcher.IsRunning do
    begin
      GetOutput(LConsoleWatcher, LResult);
      Sleep(10);
      CheckIfUserPressedCtrlC('ShellCommand');
    end;

    GetOutput(LConsoleWatcher, LResult);
    Result := LResult;
    
    LConsoleWatcher.Stop;
    LConsoleWatcher.WaitFor;
  finally
    AExitCode := LConsoleWatcher.ExitCode;
    LConsoleWatcher.Free;
  end;
end;

function GetParametersFrom(const AParams: string): TArray<string>;
var
  LParams: TStringList = nil;
  LParam: string;
  LResult: TArray<string> = [];
begin
  LParams := TStringList.Create;
  try
    LParams.Delimiter := ' ';
    LParams.StrictDelimiter := True;
    LParams.DelimitedText := StringReplace(AParams, '''', '"', [rfReplaceAll]);
    LParams.Text := StringReplace(LParams.Text, '"', '', [rfReplaceAll]);

    for LParam in LParams do
      LResult := LResult + 
        [IfThen(ContainsText(LParam, ' '), '"' + LParam + '"', LParam)];

  finally
    LParams.Free;
  end;
  Result := LResult;
end;

end.
